<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>域渗透基础知识</title>
      <link href="/2025/07/03/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/07/03/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><h3 id="什么是域？"><a href="#什么是域？" class="headerlink" title="什么是域？"></a>什么是域？</h3><p>用来描述一种架构，和“工作组”相对应，由工作组升级而来的高级架构，域(Domain)是一个有安全边界的计算机集合（ 安全边界，意思是在两个域中，一个域中的用户无法访问另一个域中的资源）。可以简单的把域理解成升级版的“工作组”，相比工作组而言，它有一个更加严格的安全管理控制机制，如果你想访问域内的资源，就必须拥有一个合法的身份登陆到该域中。</p><ul><li><p>工作组</p><p>工作组是局域网中的一个概念，他是长久的资源管理模式。默认情况下使用工作组方式进行资源管理，将不同的 computer 按照不同的要求分类到不同的组。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703110804642.png" alt="image-20250703110804642"></p></li></ul><h3 id="域的几种环境"><a href="#域的几种环境" class="headerlink" title="域的几种环境"></a>域的几种环境</h3><ul><li><p><strong>单域</strong></p><p>通常一个小公司，一般一个域就可以，一个域内，要至少两台域服务器，一台作为域控制器，另一台当备份。 </p><p>活动目录的数据库【包括用户的账号信息】是存储在域控制器中，若没备份，瘫痪了不能正常使用了。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703113658704.png" alt="image-20250703113658704"></p></li><li><p><strong>父域和子域</strong></p><p>出于管理及其他需求，需要在网络中划分多个域。第一个域称为父域，各分部的域称为该域的子域。例如大公司的各个分公司位于不同的地点，就需要使用父域及子域。如果把不同地点的分公司放在同一个域内，那么它们之间在信息交互(包括同步、复制等)上花费的时间就会比较长，占用的带宽也会比较大(在同一个域内，信息交互的条目是很多的，而且不会压缩;；在不同的域之间，信息交互的条日相对较少， 而且可以压缩)。这样处理有一个好处，就是分公司可以通过自己的域来管理自己的资源。还有一种情况是出于安全策略的考虑(每个域都有自己的安全策略)例如，一个公司的财务部希望使用特定的安全策略(包括账号密码策略等)、那么可以将财务部作为一个子域来单独管理。</p></li><li><p><strong>域树</strong></p><p>域树(Tree)是多个域通过建立信任关系组成的集合。一个域管理员只能管理本域，不能访问或者管理其他域。如果两个域之间需要互相访问，则需要建立信任关系，信任关系是连接不同域的桥梁。域树内的父域与子域，不但可以按照需要互相管理、还可以跨网络分配文件和打印机等设备及资源，从而在不同的域之间实现网络资源的共享与管理、通信及数据传输。<br>在一个域树中，父域可以包含多个子域。子域是相对父域来说的，指的是域名中的每一个段。 各子域之间用点号隔开，一个”.”代表一个层次。放在域名最后的子域称为最高级子域或一级域，它前面的子域称为二级域。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703115915385-17515152165301.png" alt="image-20250703115915385"></p></li><li><p><strong>域森林</strong></p><p>域森林( Forest)是指多个域树通过建立信任关系组成的集合。例如，在一个公司兼并场景中某公司使用域树 abc.com，被兼并的公司本来有自己的域树 abc.net，域树abc.net无法挂在域树abc.com下。</p><p>所以，域树abc.com与域树 abc.net之间需要通过建立信任关系来构成域森林，同一个林中，林根域与其他树根域自动建立双向信任关系信任关系可传递。因此，在林中，只要拥有其中一个域内的权限，就可以访问其他林中其他域的资源。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703120858490.png" alt="image-20250703120858490"></p></li></ul><h3 id="域名服务器（DNS）"><a href="#域名服务器（DNS）" class="headerlink" title="域名服务器（DNS）"></a>域名服务器（DNS）</h3><p>域名服务器( Domain Name Server,DNS)是指用于实现域名( Domain Name)和与之相对的IP地址(IP address)转换的服务器。从对域树的介绍中可以看出,域树中的域名和DNS域名非常相似。而实际上,因为域中的计算机是使用DNS来定位域控制器、服务器及其他计算机、网络服务的,所以域的名字就是DNS域的名字。在内网渗透测试中,大都是通过寻找DNS服务器 来确定域控制器的位置的(DNS服务器和域控制器通常配置在同一机器上)。</p><h3 id="活动目录-AD"><a href="#活动目录-AD" class="headerlink" title="活动目录( AD)"></a>活动目录( AD)</h3><p><code>Active Directory</code>简单来说，就是<code>Microsfot</code>提供的一项功能服务，它充当集中存储库并存储与<code>Active Directory</code>用户、计算机、服务器和组织内的其他资源等对象相关的所有数据，它使系统管理员的管理变得容易。但它的主要功能是提供一种在域环境中对用户和机器进行身份验证的方法。使用<code>Active Directory</code>，可以远程管理用户、工作站及其权限等资源。因此，它是一个可从网络上的任何地方访问的单一管理界面。它主要是<code>Microsoft Windows</code>的一项功能，但其他操作系统也可以加入其中，例如你可以在<code>Active Directory</code>环境中加入<code>Linux</code>主机。</p><p>活动目录AD是域环境中提供目录服务的组件。在活动目录中，所有的网络对象信息以一种结构化的数据存储方式来保存，使得管理员和用户能够轻松地查找和使用这些信息。活动目录以这种结构化的数据存储方式作为基础，对目录信息进行合乎逻辑的分层组织。活动目录存储着有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确从目录中查找到他所需要的信息的服务。安装有AD活动目录的服务器就是域控DC。</p><p>如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容， 活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703143946115.png" alt="image-20250703143946115"></p><h3 id="域控制器（DC）"><a href="#域控制器（DC）" class="headerlink" title="域控制器（DC）"></a>域控制器（DC）</h3><p>在域架构中域控是用来管理所有客户端的服务器，它负责每一台联入的电脑和用户的验证工作，域内电脑如果想互相访问首先都得经过它的审核。域控是域架构的核心，每个域控制器上都包含了AD活动目录数据库。一个域环境可以有多台域控，每一台域控的地位几乎是平等的，他们各自存储着一份相同的活动目录数据库。当你在任何一台域控制器内添加一个用户账号或其他信息后，此信息默认会同步到其他域控的活动目录数据库中。多个域控的好处就是，当其中有域控出现故障了，仍然能够由其他域控来提供服务，除非所有域控都出现故障。当域中的一台计算机安装了AD活动目录后，它就成了域控DC了。域控制器在进行活动目录数据库复制时，分为两种复制模式：</p><p><strong>多主机复制模式</strong>(Multi-master replication model) ：活动目录数据库内的大部分数据是利用此模式进行复制的。在此模式下，你可以直接更新任何一台域控的活动目录对象，之后这个更新过的对象会被自动复制到其他域控制器。<br><strong>单主机复制模式</strong> (Single-master replication model)：活动目录数据库内的少部分数据是采用此模式进行复制的。在此模式下，当你提出修改对象数据的请求时，会由其中一台域控负责接收与处理此请求，也就是说该对象是先在该域控被更新，再由该域控复制给其他域控。</p><p>简而言之，<code>Active Directory</code>域控制器承载对域中的身份验证请求进行响应的服务。它对网络上的用户访问进行身份验证和验证。当用户和计算机帐户登录到网络时，他们向域控制器进行身份验证，域控制器验证他们的信息(如用户名、密码)，然后决定是允许还是拒绝这些用户的访问。域控制器是攻击者的重要服务器和主要目标，因为它持有<code>Active Directory</code>环境的密钥。每个域至少有一个域控制器(也可以有其他域控制器)。</p><h2 id="域的搭建"><a href="#域的搭建" class="headerlink" title="域的搭建"></a>域的搭建</h2><h3 id="域控搭建"><a href="#域控搭建" class="headerlink" title="域控搭建"></a>域控搭建</h3><p>这里使用Vmare建立域环境</p><p>名称IP</p><p>12server1  192.168.31.161</p><p>12server2  192.168.31.162</p><p>使用12server1计算机建立域</p><p>选择 Active Directory 域服务 点击下一步 点击安装。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703154020809.png" alt="image-20250703154020809"></p><p>安装完成后，点击“将此服务器提升为域控制器”。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703154739063.png" alt="image-20250703154739063"></p><p>新建林hacker.test。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703155226059.png" alt="image-20250703155226059"></p><p>接下来设置完密码后，一直点击下一步直到安装成功即可。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703155149033.png" alt="image-20250703155149033"></p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703160216979.png" alt="image-20250703160216979"></p><p>安装成功后会自动重启服务器 输入设置的密码即可登录</p><p>目前就已成功在域环境下了</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703160741922.png" alt="image-20250703160741922"></p><h3 id="计算机加入域"><a href="#计算机加入域" class="headerlink" title="计算机加入域"></a>计算机加入域</h3><p>在 12server1的AD新建一个普通用户 test 密码Aa123456</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703162042491.png" alt="image-20250703162042491"></p><p>设置成功后 12server2的dns更改为12server1的IP：192.168.31.161</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703164441212.png" alt="image-20250703164441212"></p><p>选择我的电脑，设置隶属域hacker.test，系统提示输入账号和密码，输入刚才的 test Aa123456，确定重启即可。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703174452721.png" alt="image-20250703174452721"></p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703174729320.png" alt="image-20250703174729320"></p><p>重启后，登录域用户。</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703174858328.png" alt="image-20250703174858328"></p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250703174947489.png" alt="image-20250703174947489"></p><p>至此域环境已经搭建成功。</p><h2 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta #查看当前在线用户，qwinsta查看当前会话用户，包含登录用户</span><br><span class="line">net user #查看本机用户</span><br><span class="line">net user /domain #查看域用户</span><br><span class="line">ipconfig#查看本机IP信息</span><br><span class="line">systeminfo#查看系统详细信息</span><br><span class="line">tasklist /svc#列出进程及对应服务</span><br><span class="line">tasklist /S &lt;ip&gt; /U domain\username /P &lt;password&gt; /V 查看远程计算机tasklist</span><br><span class="line">whoami /all #查看当前身份详细权限（包括 SID、UAC 等）</span><br><span class="line">net sessoin #查看远程连接会话（需管理员权限）</span><br><span class="line">net share #查看本机共享目录</span><br><span class="line">cmdkey /l#查看保存登陆凭证</span><br><span class="line">netsh firewall show config#查看防火墙配置</span><br><span class="line">schtasks /query /fo LIST /v#查询定时任务</span><br><span class="line">net localgroup administrators &amp;&amp; whoami #查看当前是否属于管理员组</span><br><span class="line">netstat -ano#查看所有网络连接及对应PID</span><br><span class="line">dir /s *.exe #查找当前及子目录下所有.exe 文件</span><br><span class="line">spn –l administrator #查看指定用户注册的 SPN（需安装 setspn.exe 工具）</span><br><span class="line">set #查看所有环境变量</span><br><span class="line">arp -a#查看arp缓存</span><br><span class="line">net view &amp; net group &quot;domain computers&quot; /domain #第一个是基于 SMB 网络发现，第二个是真正的域组清单</span><br><span class="line">net view /domain #查看网络中所有域</span><br><span class="line">net view \\\\dc #查看指定主机（如域控）共享文件</span><br><span class="line">net group /domain #查看域中的所有组</span><br><span class="line">net group &quot;domain admins&quot; /domain #查看域管理员成员</span><br><span class="line">net localgroup administrators /domain #查看本地管理员组成员</span><br><span class="line">net group &quot;domain controllers&quot; /domain #查看域控服务器成员</span><br><span class="line">net time /domain# 获取域控时间（可间接得知IP）</span><br><span class="line">net config workstation #查看计算机名、用户、域信息</span><br><span class="line">net use \\\\域控(如 pc.xx.com)  /user:xxx.com\username password #相当于这个帐号登录域内主机，可访问资源</span><br><span class="line">nltest /dclist:&lt;domain&gt; #查看域中所有域控</span><br><span class="line">nltest /dsgetdc:&lt;domain&gt;：#获取当前最近的域控信息</span><br><span class="line">echo %logonserver% #查看认证时联系的域控</span><br><span class="line">dsquery server  #查找AD中的服务器（需 RSAT 工具）查找目录中的 AD DC/LDS 实例</span><br><span class="line">dsquery user#查找AD中的用户</span><br><span class="line">dsquery computer #查找AD中的计算机</span><br><span class="line">wmic useraccount get /all#获取域内用户详细信息</span><br></pre></td></tr></table></figure><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>在域内进行横行渗透时，首先要收集主机的端口和 ip 信息</p><p>发生系统错误 6118 出现这种错误时 Computer Browser 被禁用了在域管理启用即可 </p><p>nbtscan 发现主机</p><p>nbtscan.exe -r 192.168.0.0&#x2F;24</p><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20250704094800830.png" alt="image-20250704094800830"></p><p><strong>bat命令主机发现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for /l %i in (1,1,255) do @ping 192.168.0.%i -w 1 -n 1|find /i &quot;ttl=&quot;</span><br></pre></td></tr></table></figure><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231116202508913-17515529769863.png" alt="image-20231116202508913"></p><p><strong>用 PowerShell 实现基本的端口扫描功能。</strong> </p><p>针对单个 IP 的多个端口的扫描：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1..1024 | % &#123;echo ((new-object Net.Sockets.TcpClient).Connect(&quot;192.168.107.138&quot;,$_)) &quot;Port $_ is open!&quot;&#125; 2&gt;$null</span><br></pre></td></tr></table></figure><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231116203936628.png" alt="image-20231116203936628"></p><p>针对某 IP 段中单个端口的扫描：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">134..138 | % &#123; $a = $_; 1..1024 | % &#123;echo ((new-object Net.Sockets.TcpClient).Connect(&quot;192.168.107.$a&quot;,$_)) &quot;Port $_ is open!&quot;&#125; 2&gt;$null&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231116211502361.png" alt="image-20231116211502361"></p><p>针对某 IP 段 &amp; 多个端口的扫描器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foreach ($ip in 134..138) &#123;Test-NetConnection -Port 80 -InformationLevel &quot;Detailed&quot; 192.168.107.$ip&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231116211651346.png" alt="image-20231116211651346"></p><p><strong>基于 MSF 的内网主机探测</strong></p><p>使用 msf 进行反弹 shell 进行内网渗透时，通过 msf 自带的扫描模块进行快速扫描。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主机存活探测：</span><br><span class="line">auxiliary/scanner/discovery/arp_sweep ARP 扫描 </span><br><span class="line">auxiliary/scanner/discovery/udp_sweep UDP 扫描 </span><br><span class="line">auxiliary/scanner/netbios/nbname NETBIOS 扫描 </span><br><span class="line">auxiliary/scanner/snmp/snmp_enum SNMP 扫描 </span><br><span class="line">auxiliary/scanner/smb/smb_version SMB 扫描 </span><br><span class="line">端口扫描： </span><br><span class="line">auxiliary/scanner/portscan/ack TCP ACK 端口扫描</span><br><span class="line">auxiliary/scanner/portscan/ftpbounce FTP bounce 端口扫描</span><br><span class="line">auxiliary/scanner/portscan/syn SYN 端口扫描 </span><br><span class="line">auxiliary/scanner/portscan/tcp TCP 端口扫描 </span><br><span class="line">auxiliary/scanner/portscan/xmas TCP XMas 端口扫描</span><br></pre></td></tr></table></figure><h2 id="域渗透思路"><a href="#域渗透思路" class="headerlink" title="域渗透思路"></a>域渗透思路</h2><p>通过域成员主机，定位出域控制器 IP 及域管理员账号，利用域成员主机作为跳板，扩大渗透范围，利用域管理员可以登陆域中任何成员主机的特性，定位出域管理员登陆过的主机 IP，设法从域成员主机内存中 dump 出域管理员密码，进而拿下域控制器渗透整个内网。</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF DNS Rebinding</title>
      <link href="/2025/07/01/SSRF-DNS-Rebinding/"/>
      <url>/2025/07/01/SSRF-DNS-Rebinding/</url>
      
        <content type="html"><![CDATA[<p>DNS 重绑定是一种特定的技术，通常用于绕过 <strong>同源策略（Same-Origin Policy）</strong>。攻击者会通过操控 DNS 解析过程，伪装自己的域名，使其解析到受害者的内网 IP（例如 <strong>127.0.0.1</strong> 或 <strong>192.168.x.x</strong>）或云服务地址。这样，攻击者便能利用此技术攻击目标网络，执行多种漏洞利用方式。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><h4 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h4><p>同源策略是Web浏览器的一种安全机制，用于限制来自不同源的文档或脚本如何与另一个源的资源进行交互。</p><p>如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问</p><h4 id="什么是源？"><a href="#什么是源？" class="headerlink" title="什么是源？"></a>什么是源？</h4><ol><li><p><strong>定义</strong></p><p>Web内容的源是由用于访问它的URL的方案（协议）、主机名（域名）和端口定义。即源由<strong>协议、域名和端口</strong>组成。</p></li><li><p><strong>组成</strong></p><ul><li><strong>协议（Protocol）：</strong> 资源使用的传输协议，如<code>http</code>、<code>https</code>、<code>ftp</code>等。</li><li><strong>域名（Domain Name）：</strong> 资源的网络域名。例如<code>example.com</code>、<code>other-example.com</code> 这包括了主域名以及可能存在的子域名，如<code>www.example.com</code>和<code>mail.example.com</code>会被视为不同的子域名，除非特别配置为同源。</li><li><strong>端口（Port）：</strong> 资源服务器监听的端口号，如<code>80</code>（http默认端口）或<code>443</code>（https默认端口）。如果端口号没有显式指定，则浏览器会使用协议的默认端口。</li></ul></li></ol><h4 id="何为同源？"><a href="#何为同源？" class="headerlink" title="何为同源？"></a>何为同源？</h4><p>只有当两个资源的协议、域名和端口都完全相同时，它们才被认为是同源的。</p><p>下方URL均与<code>http://example.com/dir/index.html</code>进行比较，例如：</p><table><thead><tr><th>URL</th><th>是否同源</th><th>原因</th></tr></thead><tbody><tr><td><code>http://example.com/dir2/index.html</code></td><td>同源</td><td>只有路径不同，协议、域名和端口均相同</td></tr><tr><td><code>https://example.com/dir/index.html</code></td><td>不同源</td><td>协议不同</td></tr><tr><td><code>http://example.com:81/dir/index.html</code></td><td>不同源</td><td>端口不同</td></tr><tr><td><code>http://example.org/dir/index.html</code></td><td>不同源</td><td>主机不同（域名不同）</td></tr></tbody></table><h3 id="DNS-TLL"><a href="#DNS-TLL" class="headerlink" title="DNS TLL"></a>DNS TLL</h3><p>TTL是英语Time-To-Live的简称，意思为一条域名解析记录在DNS服务器中的存留时间。当各地的DNS服务器接受到解析请求时，就会向域名指定的NS服务器发出解析请求从而获得解析记录；在获得这个记录之后，记录会在DNS服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，DNS服务器将不再向NS服务器发出请求，而是直接返回刚才获得的记录；而这个记录在DNS服务器上保留的时间，就是TTL值。</p><p><strong>即TTL的数值越小，解析记录在本地 DNS 服务器中保留时间越短。</strong></p><h2 id="DNS-Rebinding攻击原理"><a href="#DNS-Rebinding攻击原理" class="headerlink" title="DNS Rebinding攻击原理"></a>DNS Rebinding攻击原理</h2><p>我们都知道在网络攻击形式中，是可以通过恶意网页调用受害者本地资源来进行的。然而在上述所讲的同源策略约束下，从理论上来说浏览器打开的网页是无法访问运行在本地的恶意脚本，这能够保证我们上网过程中，本地资源得到安全保护。</p><p>但是在实际中，同源策略的约束可以被轻松绕过，比如说域名重新绑定攻击就可以轻松的绕过SOP（浏览器同源策略）。</p><p>当用户PC第一次访问网站<code>http://www.a.com</code>时，会先到公共的DNS服务器上去查询<code>www.a.com</code>这个域名对应的IP地址，再根据DNS服务器返回来的IP地址去访问目标网站。如图1所示：</p><p><img src="/images/SSRF-DNS-Rebinding/DNS1.png" alt="DNS1"></p><p>一般来说我们的操作系统默认能够将DNS返回来的这个IP地址信息保存60秒，而超过60秒后如果需要再次访问<code>www.a.com</code>这个域名则需要再一次向DNS服务器查询域名的IP地址。换句话说：如果这个时候我们访问的网站设置了60秒后会调用<code>http://www.a.com/dir/</code>这个url下面的资源，那么就需要我们的PC再一次向DNS服务器进行查询该域名对应的IP地址。</p><p>假设用户访问的是一个钓鱼网站。当第一次访问该网站后过了60秒，由于该恶意网站设置了60秒后会自动调用<code>http://www.a.com/dir/</code>这个url下面的资源。用户PC访问前再次进行DNS查询的时候，DNS服务器返回的IP地址被修改为127.0.0.1，这个时候浏览器去调用<code>http://www.a.com/dir/</code>其实就变成了<code>http://127.0.0.1/dir/</code>的资源，也就是PC本地的资源。由于只是IP地址发生了改变，而浏览器实际上请求的地址还是<code>http://www.a.com/dir/</code>，所以这样其实还是符合浏览器的同源策略，但却非法的调用到了PC的本地资源。这样的行为被称之为<strong>域名重新绑定攻击（DNS ReBinding）</strong>。如图2所示：</p><p><img src="/images/SSRF-DNS-Rebinding/DNS2.png" alt="DNS2"></p><h2 id="DNS-Rebinding技术实现"><a href="#DNS-Rebinding技术实现" class="headerlink" title="DNS Rebinding技术实现"></a>DNS Rebinding技术实现</h2><p>在上述内容中，讲述了什么是域名重新绑定攻击，重点在于让DNS服务器能够在两次DNS查询中返回不同的IP地址，第一次返回的是真正的IP，第二次返回的则是攻击目标IP地址。那么如何实现公共DNS服务器下能够返回自定义信息呢？如图3所示：</p><p><img src="/images/SSRF-DNS-Rebinding/DNS3.png" alt="DNS3"></p><p>如图3所示，攻击者通过在公网上自己建立一台DNS服务器（2.2.2.2），地址为dns.b.com（与a.com不在同一域下），并在公共DNS上写入一条NS（域名）记录，将查询*.a,com的请求转发到攻击者自建的DNS服务器上面。</p><p>这个时候由于是攻击者自己的DNS服务器，攻击者就可以自定义查询的结果，如第一次查询返回的IP地址设置为钓鱼网站<code>www.a.com</code>的IP，第二次查询返回的地址为要攻击的目标IP 127.0.0.1，以此来完成DNS ReBinding攻击。</p><p>简单理一下这个过程：</p><ol><li>攻击者配置了一台DNS服务器用于解析某域名。</li><li>每次请求后返回的解析结果不一样，分别是一个合法地址，一个是恶意地址。</li><li>当服务器在第一次请求的时候返回合法地址，第二次请求时返回的是恶意地址。就可以绕过限制进行利用。</li></ol><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>访问靶场，并填写相关信息</p><p><img src="/images/SSRF-DNS-Rebinding/image-20250702175646945.png" alt="image-20250702175646945"></p><p>提交后显示check url faild，说明有个check函数进行了校验过滤</p><p><img src="/images/SSRF-DNS-Rebinding/image-20250702175727066.png" alt="image-20250702175727066"></p><p>通过自建DNS服务器进行DNS重绑定（此处用网上平台进行利用），A绑定了自己的vps地址，B绑定了docker.ip</p><p><img src="/images/SSRF-DNS-Rebinding/image-20250702180132025.png" alt="image-20250702180132025"></p><p>在vps上起一个web服务，端口不为80与8080，写一个<code>index.php</code>页面用于跳转：(我这里用的端口为7777)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#index.php内容</span><br><span class="line">&lt;?php  </span><br><span class="line">header(&quot;Location:http://127.0.0.1:8787/ssrf/flag&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>启用web服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S 0.0.0.0 7777</span><br></pre></td></tr></table></figure><p>因为服务器那边解析不一定会按照预想的来，因此需要不停的发包来碰撞。最终拿到flag如下：</p><p><img src="/images/SSRF-DNS-Rebinding/image-20250702180637747.png" alt="image-20250702180637747"></p><h2 id="传统的SSRF过滤流程"><a href="#传统的SSRF过滤流程" class="headerlink" title="传统的SSRF过滤流程"></a>传统的SSRF过滤流程</h2><ol><li>获取输入的URL，从该URL中提取HOST，如果提取出来的是IP，那么直接跳到第三步；</li><li>对该HOST进行DNS解析，获取到解析的IP；</li><li>检测该IP是否是合法的，比如是否是私有IP等（是就直接终止流程）；</li><li>如果IP检测为合法的，则进入CURL发包；</li></ol><p>从DNS解析的角度来看，这个过程一共有两次解析，第一次是<strong>对该host进行DNS解析</strong>，第二次是<strong>进入curl的阶段发包</strong>，这两次请求之间存在一个时间差，如果我们能够修改DNS地址在第一次请求的时候为合法地址，第二次请求时为恶意地址，就可以绕过这个检测了。</p><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><ul><li>白名单验证：仅允许请求特定的受信任域名或 IP 地址。</li><li>限制超时时间：限制服务器发起请求的超时时间，减少攻击窗口。</li><li>检查 URL 格式：验证 URL 参数是否合法，避免构造恶意的 URL。</li><li>安全配置：配置服务器和网络设备以限制出站连接，防止与恶意域名建立连接。</li><li>使用随机 Token：为每个请求生成随机的 token，并在响应中验证该 token，防止请求被滥用。</li></ul><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><h3 id="IP双重绑定绕过"><a href="#IP双重绑定绕过" class="headerlink" title="IP双重绑定绕过"></a>IP双重绑定绕过</h3><p>一般PHP在获取IP的时候通常是使用gethostname或者dns_get_record这俩函数。</p><p>在一个域名下，同时绑定两个IP，如果使用的是gethostname来获取IP，则只会返回一个，返回哪个IP则是随机的。</p><p>但是curl在访问这种域名的时候，由于绑定的是两个IP，curl会尝试访问每一个IP，最终返回有效的那个。比如我一个域名绑定了两个IP，一个是1.1.1.1（80端口关闭），一个是2.2.2.2（80端口开放），在curl这个域名的时候，会返回2.2.2.2的请求结果。</p><p>如果SSRF过滤逻辑使用的是gethostname或者只获取了dns_get_record返回数组的第一个元素，那么就会存在被绕过的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
